---
uid: 6270
title: 如何更有效地利用“标题”
tags: [obsidian, 插件, 脚本]
description: 如何更有效地利用“标题”
author: Moy
type: other
draft: false
editable: false
modified: 20251126151302
forum_url: https://forum.pkmer.net/t/5680
---

# 如何更有效地利用“标题”

> [!INFO] 本文档由 PKMer 论坛导入  
> - 作者: Moy
> - 原始链接: [如何更有效地利用“标题”](https://forum.pkmer.net/t/5680)

---


很多时候，我们会用 `文件名` 来作为搜索时候的关键字。

比如说，搜索“苹果派”，可以找到 `苹果派.md` 这个笔记。

但是——如果不是严格践行原子笔记的方法，将每篇笔记都拆到极小，那么很多时候并没不会给每个“主题”都专门创建单独的笔记。

比如，如果我只是有一个 `想要尝试的菜谱.md` 笔记，里面有 `## 苹果派 `、` ## 千层蛋糕` 等子标题……
这个情况下，我要如何更好地利用这些**标题**呢？

![image|357x500](https://cdn.pkmer.cn/original/1X/f04731c7f6a70b4fa2b777c95402ac4f3320f81d.jpeg)


## I. 搜索
在搜索/快速打开方面，我会推荐使用 **Quick Switcher++** 插件的 Heading Mode 标题检索模式。

在这个模式下，它会搜索库内所有的标题。
![image|690x371](https://cdn.pkmer.cn/original/1X/58e9565a18730218fbda69dcc269769e126e3c70.png)


> 我直接给这个搜索模式分配了默认的 <kbd>Ctrl+P</kbd> 快捷键


### 文件名作为标题

有同学可能会问：老师，那每次搜索前我得先确定搜的是文件名还是标题，这不是很麻烦吗？

这就涉及到一个知识点——“<mark>把文件名作为一级标题</mark>”。

这样一来，每个文件名同时也是文档的最高标题，搜索框可以同时检索“文件名”和“标题”。
（这其实算是一种约定俗成的 markdown 规范）

你可以使用 **Linter** 插件来自动给每个文件都自动格式化成“文件名作为标题”：

![image|690x373](https://cdn.pkmer.cn/original/1X/e9c91bf1b4a83901c97d0b546c453c645e654dbd.png)


我个人则是在 Templater 的模板中就自动生成同名的一级标题：

```md
<%*
let filename = tp.file.title;
-%>
# <% filename %>
```

## II. 嵌入
在双链笔记中，文件名的另一个作用则是：**快速嵌入**。

例如，使用 `[[苹果派]]` 就可以快速嵌入一个笔记；
但如果要插入 `[[菜谱#苹果派]]`，这样就麻烦不少——不但输入步骤变多，而且文本还变长了。

### 文本长度
对于文本长度，可以用 `[[菜谱#苹果派|苹果派]]` 来将它显示为 `苹果派`。

> 这个是 wiki 链接中“显示文本”的语法，markdown 链接的格式中写成： `[苹果派](菜谱#苹果派)`

### 快速插入
但是，这样要输入更多的文字——更麻烦了。

有没有更省力的方案呢？
![image|161x187](https://cdn.pkmer.cn/original/1X/0cb870fb3de55b971024e05c2adb6a53b0a6fe05.png)


有的兄弟，有的。

我写了一个脚本，可以直接搜索所有的标题，并且用上述格式插入。

![image|690x180](https://cdn.pkmer.cn/original/1X/8f4724cb20fdaa9c510a87057ff5149360d8220e.png)


使用效果：
![250709_更有效地利用标题-img-250709_130636|690x362](upload://1TII6cs7NubkHNxlM7ITXryDoTs.gif)


脚本地址：[Gist: 搜索并插入标题链接](https://gist.github.com/Moyf/999276158867512893e76008aeb85616)

如果没法访问，也可以直接复制粘贴以下内容：

````js
<%* 
const headings = [];
const headingDict = {};

const files = app.vault.getMarkdownFiles();
files.forEach(file => {
    let headingsInNote = app.metadataCache.getFileCache(file).headings;
    if (headingsInNote) {
        headingsInNote.forEach(heading => {
            if (heading.heading){
                const headingStr = heading.heading;
                const headingDisplayText = `[#${headingStr}]  | ${file.basename}`;
                const LinkContent = `[[${file.basename}#${headingStr}|${headingStr}]]`;
                const selection = {
                    headingStr: headingDisplayText,
                    LinkContent: LinkContent
                }
                // console.log(headingStr);
                headingDict[headingDisplayText] = LinkContent;
                headings.push(selection);
            }
        });
        // headings.concat(app.metadataCache.getFileCache(file).headings);
        // console.log(app.metadataCache.getFileCache(file).headings);
    };
});

const userSelected = await tp.system.suggester( (item) => item.headingStr, headings)
console.log(userSelected);

tR += userSelected ? userSelected.LinkContent : "";

%>
````

（保存到自己的库里，后缀名用 `.md`，然后用 Templater 模板调用该脚本）

## 结语
这篇文章分享了：

- 2个插件：Quick Switcher ++ 快速检索、Linter 格式化
- 1个脚本：搜索全库的标题并插入文档

但是，除了工具层面，更主要的是分享我自己对于“标题”的用法。

我自己的笔记工作流中，通常会将一个“主题”先记录在特定的汇总页面中，例如我有一个“插件记录”的笔记，会将看到的一些有趣的插件先作为标题记录下来：

![image|690x401](https://cdn.pkmer.cn/original/1X/a19f08547c1247136591ea881bd0f332c3b481fb.png)

如果这个插件足够有趣或者有用，我才会给它单独开一个专题笔记：
![Snipaste_2025-07-09_13-25-14|690x407](https://cdn.pkmer.cn/original/1X/1e73c24403aabfa75d2dfc0c9ce7e699216c6aec.jpeg)

这是我管理“小主题”和“专题”的方式，而在这篇文章“**将标题作为子文件名**”使用的这个工作流中，<mark>我可以自由地在不同主题之间浏览，而不需要在意它是否是单独文件。</mark>

希望这个分享能对你们有所帮助。
